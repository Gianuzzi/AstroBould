!> Module with filtering methods
module filter
    use constants, only: pi, uno, uno2, dos, tini
    implicit none
    ! filter parameters
    real(kind=8) :: filt_dt, filt_freq
    integer(kind=4) :: filt_size, filt_half_size
    real(kind=8) , allocatable :: filt_kernel(:)  ! convolution kernel
    real(kind=8) , allocatable :: filt_values(:)  ! filtered values
    real(kind=8) , allocatable :: filt_tmp_values(:)  ! values to use for filtering
    
contains

    subroutine create_filter(filter_dt, filter_size, low_pass)
        implicit none
        real(kind=8), intent(in) :: filter_dt
        integer(kind=4), intent(in) :: filter_size
        logical, intent(in) :: low_pass
        integer(kind=4) :: j
        real(kind=8) :: omega_pass, t_j, norm

        !------------------------
        ! Assign parameters
        !------------------------
        if (mod(filter_size, 2) .eq. 0) then
            filt_size = filter_size + 1
        else 
            filt_size = filter_size
        end if
        filt_half_size = int((filter_size - 1) / 2, 4)
        filt_dt = filter_dt
        filt_freq = dos * filter_dt

        omega_pass = dos * pi * filt_freq  ! Frequency allowed

        ! Allocate kernel
        allocate(filt_kernel(filt_size))

        !------------------------
        ! Build sinc low-pass kernel
        ! hkernel_j = sin(omega_pass * t_j) / (pi * t_j)
        ! For j = 0, use limit value 1
        !------------------------
        do j = -filt_half_size, filt_half_size
            t_j = dble(j) * filt_dt
            if (abs(t_j) < tini) then
                filt_kernel(j + filt_half_size + 1) = uno
            else
                filt_kernel(j + filt_half_size + 1) = sin(omega_pass * t_j) / (pi * t_j)
            end if
        end do

        !------------------------
        ! Normalize kernel to unity sum
        !------------------------
        norm = sum(filt_kernel)
        filt_kernel = filt_kernel / norm

        if (.not. low_pass) then
            !------------------------
            ! Reverse to obtain high-pass kernel
            !------------------------
            filt_kernel = - filt_kernel
            filt_kernel(filt_half_size + 1) = uno + filt_kernel(filt_half_size + 1)
        end if

    end subroutine create_filter

    subroutine allocate_filter(filter_size, data_size)
        implicit none
        integer(kind=4), intent(in) :: filter_size, data_size

        allocate(filt_tmp_values(data_size, filter_size))
        allocate(filt_values(data_size))    
        
    end subroutine allocate_filter

    subroutine setup_filter(filter_dt, filter_size, low_pass, data_size)
        implicit none
        real(kind=8), intent(in) :: filter_dt
        integer(kind=4), intent(in) :: filter_size, data_size
        logical, intent(in) :: low_pass

        call create_filter(filter_dt, filter_size, low_pass)

        call allocate_filter(filt_size, data_size)   
        
    end subroutine setup_filter

    subroutine store_to_filter(state_vector, data_size, filter_index)
        implicit none
        real(kind=8), dimension(:), intent(in) :: state_vector
        integer(kind=4), intent(in) :: data_size, filter_index

        filt_tmp_values(1:data_size, filter_index) = state_vector(1:data_size)    
        
    end subroutine store_to_filter

    subroutine apply_filter(data_size, filtered)
        implicit none
        integer(kind=4), intent(in) :: data_size
        real(kind=8), dimension(:), intent(out) :: filtered
        real(kind=8) :: cos_th, sin_th
        integer(kind=4) :: i, j

        ! init to 0
        filtered(1:data_size) = cero
        cos_th = cero
        sin_th = cero

        do j = 1, filt_size
            cos_th = cos_th + cos(filt_tmp_values(1, j)) * filt_kernel(j)
            sin_th = sin_th + sin(filt_tmp_values(1, j)) * filt_kernel(j)
            filtered(2:data_size) = filtered(2:data_size) + filt_tmp_values(2:data_size, j) * filt_kernel(j)
        end do

        ! Angle filtered
        filtered(1) = modulo(atan2(sin_th, cos_th) twopi)
        
    end subroutine apply_filter
    
    subroutine deallocate_filter(filter_size, data_size)
        implicit none
        integer(kind=4), intent(in) :: filter_size, data_size

        if allocated(filt_tmp_values) deallocate(filt_tmp_values)
        if allocated(filt_values) deallocate(filt_values)
        
    end subroutine deallocate_filter

    
end module filter